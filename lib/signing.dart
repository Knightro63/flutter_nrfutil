import 'package:basic_utils/basic_utils.dart';
import 'package:archive/archive_io.dart';
import 'dart:typed_data';
import 'package:nrfutil/terminal/logger.dart';

/// The types of key signing are pem files or c code.
enum SigningKeyType{code,pem}

/// This is a return type for generating Singing key.
///
/// This returns:
/// pem type private key
/// pem type public key
/// c code for public key
/// Zip file which includes all the key types
class SigningKeyData{
  SigningKeyData({
    required this.privateKey,
    required this.publicKeyCode,
    required this.publicKeyPem,
    required this.zipFile
  });

  String privateKey;
  String publicKeyCode;
  String publicKeyPem;
  Uint8List zipFile;
}

/// Represents the SigningKey data.
///
/// This data contains private key, public key, and signiture.
class SigningKey{
  SigningKey({
    this.privateKey,
    this.publicKey,
    this.signature,
  });
  ECPrivateKey? privateKey;
  ECPublicKey? publicKey;
  ECSignature? signature;

  bool get hasPrivateKey => (privateKey != null);
  bool get hasSignature => (signature != null);
  bool get hasPublicKey => (publicKey != null);

  @override
  String toString(){
    return {
      'privateKey': privateKey.toString(),
      'publicKey': publicKey.toString(),
      'signature': signature.toString(),
    }.toString();
  }
}

/// The options used to configure a Key Signing.
///
/// ```dart
/// Signing(
///   privateKey: 'in the form of String or Uint8List',
///   publicKey: 'in the form of String or Uint8List'
/// );
/// ```
/// 
/// If a key needs to be generated 
/// ```dart
/// Signing.generateKey()
/// ```
/// 
/// To verify the data is signed correctly call
/// ```dart
/// bool verify = Signing().verify(signedData)
/// ```
class Signing{
  Signing({
    String? privateKey,
    String? publicKey,
    bool isVerbose = false
  }){
    if(privateKey != null){
      _loadPrivateKeyFromPem(privateKey);
    }

    if(publicKey != null){
      if(publicKey.contains('-----BEGIN')){
        _loadPublicKeyFromPem(publicKey);
      }
      else if(publicKey.contains('__ALIGN(4)')){
        _loadPublicKeyFromCode(publicKey);
      }
      else{
        throw'Error Failed to load Public Key!';
      }
    }
  }

  SigningKey signingKey = SigningKey();
  final String defaultKey = """-----BEGIN EC PRIVATE KEY-----
  MHcCAQEEIGvsrpXh8m/E9bj1dq/0o1aBPQVAFJQ6Pzusx685URE0oAoGCCqGSM49
  AwEHoUQDQgAEaHYrUu/oFKIXN457GH+8IOuv6OIPBRLqoHjaEKM0wIzJZ0lhfO/A
  53hKGjKEjYT3VNTQ3Zq1YB3o5QSQMP/LRg==
  -----END EC PRIVATE KEY-----""";
  List<int> signature = [];

  /// Create SingingKeyData which includes a zip file that contains both a public and private key.
  /// The public key is in the form of c code and pem file in SingingKeyData. 
  ///
  /// To export a zip file with all the needed keys, call [generateKey].
  static SigningKeyData generateKey({NRFLogger? logger}){
    late String pbkc;
    late String pbkpem;
    AsymmetricKeyPair pair = CryptoUtils.generateEcKeyPair();
    Archive archive = Archive();
    logger?.verbose('Creating private key.');
    String prk = CryptoUtils.encodeEcPrivateKeyToPem(pair.privateKey as ECPrivateKey);
    archive.addFile(ArchiveFile('private.pem', prk.length, prk));
    
    //if(publicKeyType == SigningKeyType.code){
      logger?.verbose('Creating public code key.');
      ECPublicKey ecpbk = pair.publicKey as ECPublicKey;
      pbkc = _generateCodeKey(ecpbk);
      archive.addFile(ArchiveFile('public.c', pbkc.length, pbkc));
    //}
    //else{
      logger?.verbose('Creating public pem key.');
      pbkpem = CryptoUtils.encodeEcPublicKeyToPem(pair.publicKey as ECPublicKey);
      archive.addFile(ArchiveFile('public.pem', pbkpem.length, pbkpem));
    //}
    logger?.verbose('Archiving keys.');
    ZipEncoder encoder = ZipEncoder();
    OutputStream outputStream = OutputStream(
      byteOrder: LITTLE_ENDIAN,
    );
    List<int>? bytes = encoder.encode(
      archive,
      level: Deflate.BEST_COMPRESSION, 
      output: outputStream
    );
    return SigningKeyData(
      zipFile: Uint8List.fromList(bytes!),
      privateKey: prk,
      publicKeyCode: pbkc,
      publicKeyPem: pbkpem
    );
  }
  /// Generates the code form of the public key.
  static String _generateCodeKey(ECPublicKey ecpbk){
    Uint8List pbke = ecpbk.Q!.getEncoded(false);
    List<int> pbkList = (pbke.sublist(1,33).reversed.toList()+pbke.sublist(33,65).reversed.toList());
    String pbkHexString = '';

    for(int i = 0; i < pbkList.length; i++){
      pbkHexString += '0x${pbkList[i].toRadixString(16).padLeft(2,'0')}';
      if(i < pbkList.length-1){
        pbkHexString += ', ';
      }
    }
    String date = DateTime.now().toString();
    return 
"""/* This file was automatically generated by nrfutil on $date */
#include "stdint.h"
#include "compiler_abstraction.h"

/** @brief Public key used to verify DFU images */

__ALIGN(4) const uint8_t pk[64] ={
  $pbkHexString
};
""";
  }
  /// Loads a private key from Pem file.
  void _loadPrivateKeyFromPem([String? key]){
    logger?.verbose('Loading Private Key From Pem.');
    signingKey.privateKey = key == null?CryptoUtils.ecPrivateKeyFromPem(defaultKey):CryptoUtils.ecPrivateKeyFromPem(key);
  }
  /// Loads a private key from Uint8List.
  void _loadPrivateKeyFromBytes(Uint8List? bytes){
    logger?.verbose('Loading Private Key From Bytes.');
    signingKey.privateKey = bytes == null?CryptoUtils.ecPrivateKeyFromPem(defaultKey):CryptoUtils.ecPrivateKeyFromDerBytes(bytes);
  }
  /// Loads a public key from Uint8List.
  void _loadPublicKeyFromBytes(Uint8List bytes){
    logger?.verbose('Loading Public Key From Bytes.');
    signingKey.publicKey = CryptoUtils.ecPublicKeyFromDerBytes(bytes);
  }
  /// Loads a public key from PEM file.
  void _loadPublicKeyFromPem(String key){
    logger?.verbose('Loading Public Key From Pem.');
    signingKey.publicKey = CryptoUtils.ecPublicKeyFromPem(key);
  }
  /// Loads a public key from PEM file.
  void _loadPublicKeyFromCode(String key){
    logger?.verbose('Loading Public Key From Code.');
    String hexString = key.split('{')[1].replaceAll('};', '').replaceAll(' ', '').replaceAll('\n', '');
    List<String> data = hexString.split(',');
    List<int> pbkList = [];

    for(int i = 0; i < data.length; i++){
      pbkList.add(int.parse(data[i]));
    }

    ECDomainParameters ecDomainParameters = ECDomainParameters('prime256v1');
    ECPoint? Q = ecDomainParameters.curve.decodePoint([4]+pbkList.sublist(0,32).reversed.toList()+pbkList.sublist(32,64).reversed.toList());
    signingKey.publicKey = ECPublicKey(Q, ecDomainParameters);
  }
  /// Create signature for init package using P-256 curve and SHA-256 as hashing algorithm.
  ///
  /// Returns R and S keys combined in a 64 byte array to sign data, call [sign].
  Uint8List sign(Uint8List dataToSign){
    if(!signingKey.hasPrivateKey) throw Exception("Can't save key. No key created/loaded");
    ECSignature es = CryptoUtils.ecSign(signingKey.privateKey!, dataToSign, algorithmName: 'SHA-256/ECDSA');
    signingKey.signature = es;
    List<int> r = _bigIntToUint8List(es.r).reversed.toList();
    List<int> s = _bigIntToUint8List(es.s).reversed.toList();
    return Uint8List.fromList(r+s);
  }

  /// Change Big int to Uint8List.
  Uint8List _bigIntToUint8List(BigInt bigInt) => _bigIntToByteData(bigInt).buffer.asUint8List();

  /// Change Big int to byte data list.
  ByteData _bigIntToByteData(BigInt bigInt) {
    final data = ByteData((bigInt.bitLength / 8).ceil());
    BigInt newBigInt = bigInt;

    for (int i = 1; i <= data.lengthInBytes; i++) {
      data.setUint8(data.lengthInBytes - i, newBigInt.toUnsigned(8).toInt());
      newBigInt = newBigInt >> 8;
    }

    return data;
  }
  /// Verify if the data is signed correctly with both keys.
  ///
  /// To verify if the data is signed correctly, call [verify].
  bool verify(Uint8List signedData){
    if(!signingKey.hasSignature || !signingKey.hasPublicKey){ 
      //throw Exception("Can't save key. No key created/loaded");
      logger?.verbose('Unable to verify! No Public Key Provided!');
      return false;
    }
    else{
      logger?.verbose('Verifying Data!');
      bool ver = CryptoUtils.ecVerify(
        signingKey.publicKey!, 
        signedData, 
        signingKey.signature!, 
        algorithm: 'SHA-256/ECDSA'
      );
      ver?logger?.verbose('Data Verified!'):logger?.verbose('Data Invalid!');
      return ver;
    }
  }
}
